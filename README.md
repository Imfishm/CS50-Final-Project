# Sudoku Solver
#### Video Demo: <https://www.youtube.com/watch?v=suIpmI2umpM>
#### Description:

The Sudoku Puzzle Solver (or Sudoku Solver) is a web application which can be used in order to solve sudoku puzzles. The main GUI utilizes an interactive grid, wherein users can enter any unfinished sudoku puzzle they wish. Upon clicking the "Solve!" button at the bottom of the screen, the puzzle is submitted as a form, solved, and then displayed to the user on the same grid in which they entered the incomplete puzzle.

### Project Files:
- **styles.css**: This file provides the styling for most elements in all of the HTML files used for this project, such as the main sudoku grid itself.
- **index.html**: This file contains the main HTML structure of the sudoku solver, as well as some of its functionality, and acts as the home page of the web application.
- **layout.html**: This file contains the basic structure for all HTML files used throughout the project, helping to make the web application maintain a sleek and consistent look.
- **learn.html**: This is a very simple HTML file, which provides the user with information about the sudoku game, such as its history, its rules, and tips on how to improve at the game.
- **resources.html**: This file contains all of the various resources used throughout the project, such as for programming the web-application, the algorithm used for the solver, etc.
- **app.py**: This is the main server-side file, which utilizes Python and Flask in order to handle the logic for solving the puzzle, and outputting its solution back into the front-end.
- **solvers.py**: This file contains some helper functions used in the core process of solving the sudoku puzzle in 'app.py'. This includes the brute-force algorithm used for solving.
- **requirements.txt**: This file contains all of the required dependencies which need to be installed in order to launch the web application.

### Design Choices:
This application was designed to be as simple to use as possible. The user interface is extremely simple and interactive, allowing the user to have an extremely smooth experience. Some of these design choices include the sudoku grid being fully interactive, allowing the user to directly input numbers into the grid, simplifying the core function of the app to a highly visual process. Also, a navigation bar is included at the top of the website, so that the user can easily flip through different pages of the web application. In terms of stylization, it is kept extremely minimal, so that the main functions of the application are not obfuscated in any way. Overall, the core concept (the solver itself) is what is centralized for this web application. I wanted it to remain the basis of this project and did not want anything to distract away from it, so everything is kept very minimal. For this reason, I went to extra lengths to make sure the sudoku solver stood out, mainly through its dynamic nature. Aside from being able to solve puzzles with it, the solver does a couple of nice things; firstly, it will highlight all of the parts of the puzzle which the algorithm has solved. This ensures that the user can clearly distinguish between parts that they themselves provided, and parts of the puzzle which were solved for them. Lastly, flash messages are a very useful integration into the logic of the solver. They work not only as error checks, telling when they've done something wrong, and what exactly went wrong, but also let the user know when they've done everything successfully, and the puzzle is solved. Once again, everything in this web application revolves around the main puzzle solver, which is why I went to such great lengths to highlight it as the centerpiece.

### Challenges and Solutions:
Of course, the main challenge when making this application was the solver itself. Before I had discovered the brute-force algorithm, I was essentially just guessing and trying to figure out how sudoku puzzles worked by reading up on them. However, upon discovering multiple sudoku algorithms, I eventually settled on finding a way to implement a brute-force algorithm. Although I am aware that this algorithm is not the most efficient (as the name suggests), I ultimately decided that it would work best for me, since it seemed to have the most straightforward, programmatic, implementation. There were, of course, several other challenges along the way, particularly with integrating the logic of my solver with the visual display of my HTML files, but this was mostly solved by painstakingly reading through various documentations, as well as some help from YouTube.

### Future Improvements:
There are only a couple of things I have in mind that I may or may not decide to come back and change in the future: firstly, the solver itself. Although I haven't had any issues after several tests, implementing a smarter (and therefore faster) algorithm would always be a good idea, since it could only speed up the time it takes to solve a puzzle. Secondly, the flash messages work in a somewhat wonky way right now, and makes the stylization of all the pages a bit strange (namely, there is this strange colored gap between the navabar and the main solver page, where the flash messages appear). Also, I am still on the fence about whether or not the messages should fade away or stay, but for now, I'm just going to have them fade out, and gather feedback later on.

### Conclusion:
Overall, I found this project to not only be an extremely fun experience, but also an extremely valuable one. Starting with the fun bit, I always enjoy having the freedom to create something of my choosing, and this project could not have been any closer to just that. I love the fact that I was able to put myself in the hot seat, and prove to myself that I can make something I am actually extremely proud of. Now the valuable part. CS50 as well as this project have boosted my confidence immensely. When I first started learning how to program with one of my close friends, I was constantly comparing myself to others, and was always so unbelievably disappointed with how little I could do in comparison to what other people had already accomplished. But now, thanks to CS50 and this project, I have gained the knowledge, tools, and experience I need to be able to continue my programming journey forwards. I now feel that the heavy lifting I need to do comes from making ideas, as this course has given me the ability to breathe anything I want from my imagination into life. CS50 has been more valuable to me than can be put into words, and I don't know what kind of person I may have turned out to be without it. Thank you to everyone who made CS50, and subsequently, my own journey possible.
